# Teil - 7: API-Tests, API-Integration und Security 
Playwright liefert bereits einige Mittel mit, um REST-APIs zu verwenden. Diese M√∂glichkeiten werden in diesem Teil beleuchtet.

Motivation
F√ºr die Interaktion mit REST-APIs kann es folgende Anwendungsf√§lle geben:

Testen einer serverseitigen API
Testen funktionaler Anforderungen
Testen nicht-funktionaler Anforderungen (z.B. IT-Sicherheit)
Nutzen einer API, um einen serverseitigen Zustand vor dem Test herzustellen
Nutzen einer API, um einen serverseitigen Zustand nach einem Test zu validieren
In diesem Tutorial wird sich prim√§r auf das funktionale und nicht-funktionale Testen einer API fokussiert, da die anderen beiden F√§lle sehr abh√§ngig von der jeweiligen Implementierung sind.

Allgemeiner Ansatz
Im vergleich zu der Browser-basierten Interaktion wird f√ºr die Interaktion mit einer REST-API ein entsprechender REST-Client verwendet.

Die Interaktion basiert dabei auf einem Request-Response Muster.
Ein Requests setzt sich aus gew√§hlten Methode / dem HTTP-Verb, einem Pfad, sowie Abfrageparametern zusammen.
Playwright bringt hierf√ºr einen eigenen APIRequestContext mit.
Weitere Informationen zum API-Testing mit Playwright
Aufgabenstellung
Um den Taschenrechner angenehmer zu gestalten, sollten zus√§tzlich noch interessante Fakten √ºber Katzen angeboten werden. Dies soll √ºber eine Katzen-Fakten-API umgesetzt werden.

Verwendete API: catfact

Umsusetzener Testfall: Es soll getestet werden, dass bei einer Anfrage nach 2 Fakten auch genau diese Anzahl zur√ºckgemeldet wird.

Schreiben des Testfalls
Erstellen einer neuen Feature-Datei cats.feature
Tagging mit @feature-3
Benennen der Funktionalit√§t: 'Automatische Ermittlung n√ºtzlicher Fakten √ºber Katzen'
Beschreibung der Funktionalit√§t: 'In meiner Rolle als Buchhalter*in m√∂chte interessante Fakten √ºber Katzen lernen, um mich von den schweren Kalkulationen zu erholen.'
Schreiben des ersten Szenarios: 'Ermittlung von mehreren Katzen-Fakten'
Aufbau orientiert sich an den Bestandteilen eines Requests:
Aufbauen eines Requests an die URLS der Katzen-API
Setzen der eine Parameters: Hier limit = 2
Absenden des Requests
Valideiren der Antwort: Hier kontrolle ob wirklich 2 Fakten ausgeliefert wurden

# language: de

@feature-3
Funktionalit√§t: Automatische Ermittlung n√ºtzlicher Fakten √ºber Katzen
  In meiner Rolle als Buchhalter*in m√∂chte interessante Fakten √ºber Katzen lernen,
  um mich von den schweren Kalkulationen zu erholen.

  Szenario: Ermittlung von mehreren Katzen-Fakten
    Gegeben sei ein Request an die Katzen-Fakten-API
    Wenn ich als limit Parameter 2 setze
    Und ich den Request absende
    Dann erwarte ich 2 Fakten √ºber Katzen
Umsetzen des Tests
Zuerst m√ºssen ein paar Anpassungen an den bisherigen Informationen des Starter-Repos vorgenommen werden
In der src/support/config.ts wird die BASE_URL auf <https://catfact.ninja> ge√§ndert.
Da wir wieder einen Zustand √ºber mehrere Steps halten m√ºssen, ist auch eine Anpassung der World in src/support/custom-world.ts notwendig.
Umbenennen von server zu requestContext (besserer Name)
Erg√§nzen von requestPath: string, requestParams: string (Zwischenl√∂sung), requestResponse: APIResponse
Darauf achten, dass alle Klassen entsprechen Importiert wurden
Durch das Umbennen von server wird auch die src/support/common-hooks.ts angepasst, aber es sind keine weiteren Erg√§nzungen notwendig.
Implementieren der Katzen-API spezifischen Schritte
Gegeben sei ein Request an die Katzen-Fakten-API
Setzen des spezifischen Pfades im requestPath der World
Dieser wird dann inhaltlich kombiniert, mit dem BASE_PATH der in der src/support/common-hooks.ts bei der Erzeugung gesetzt wird.
Wenn ich als limit Parameter 2 setze
Setzt des entsprechenden √úbergabewerts als limit Parameter in den requestParams der World
Und ich den Request absende
Zusammensetzen der einzelnen Bestandteile requestContext, requestPath und requestParams aus der World als GET-Request
Speichern des Ergebnisses in requestResponse der World
Dann erwarte ich 2 Fakten √ºber Katzen
Auslesen des Response-Bodys
Diese muss noch in einen String und dann in ein Objekt geparst werden, um leicht damit zu interagieren
Im Anschluss befinden sich die Fakten innerhalb des data-Kontens als Array und k√∂nnen auf deren L√§nge √ºberpr√ºft werden
Als Bonus k√∂nnen noch die Fakten ausgegeben werden, dass wir auch etwas davon haben üòÑ
import { ICustomWorld } from '../support/custom-world';
import { Given, Then, When } from '@cucumber/cucumber';
import { expect } from '@playwright/test';

Given('ein Request an die Katzen-Fakten-API', async function (this: ICustomWorld) {
  this.requestPath = '/facts';
});

When('ich als limit Parameter {int} setze', async function (this: ICustomWorld, value: number) {
  this.requestParams = { limit: value };
});

When('ich den Request absende', async function (this: ICustomWorld) {
  this.requestResponse = await this.requestContext?.get(this.requestPath!, {
    params: this.requestParams,
  });
});

Then(
  'erwarte ich {int} Fakten √ºber Katzen',
  async function (this: ICustomWorld, expectedResultCount: number) {
    const buffer = await this.requestResponse?.body();
    const result = JSON.parse(buffer!.toString());
    expect(result.data.length).toEqual(expectedResultCount);
    console.log(result.data.map((entry: { fact: string }) => entry.fact));
  },
);
Verschieben des allgemeing√ºltigen Schritts
Der Step wenn ich den Request absende beinhaltet keine spezifischen Informationen zur Katzen-API, wesshalb dieser wieder in eine generelle Datei verschoben werden kann. Beispielweise durch Refactoring wird dieser Schritt in die general-api.steps.ts verschoben.

Ausf√ºhren der Tests
Um gezielt nur die API Tests auszuf√ºhren, wird der Befehl npm run test features/cats.feature verwendet. Im Browser ist zu erkennen, dass hier nun keine Webseite geladen wird. Dies ist der Fall, da die API Kommunikation komplett im Hintergrund ausgef√ºhrt wird. Als Ergebnis erhalten wird auf der Console zwei Fakten zu Katzen. Zum Beispiel:

  @feature-3
  Szenario: Ermittlung von mehreren Katzen-Fakten # features\cats.feature:7
    Gegeben sei ein Request an die Katzen-Fakten-API
    Wenn ich als limit Parameter 2 setze
    Und ich den Request absende
    Dann erwarte ich 2 Fakten √ºber Katzen
[
  'Unlike dogs, cats do not have a sweet tooth. Scientists believe this is due to a mutation in a key taste receptor.',
  'When a cat chases its prey, it keeps its head level. Dogs and humans bob their heads up and down.'
]
Erweiterung der Aufgabenstellung
Der erste Teil hat ein beispiel gegeben, wie eine API explizit getestet werden kann und wie die relevanten Testschritte deutlich in Cucumber dargestellt werden. Wenn ein API-Request daf√ºr verwendet werden soll, nur einen serverseitigen Zustand zu erzeugen oder zu ermitteln, so k√∂nnen die einzelnen Schritte aus dem Testfall zuvor auch zusammengefasst werden. Dies ist die Aufgabe f√ºr den kommenden Abschnitt.

Schreiben des Testfalls
Schreiben eines neuen Szenarios mit nur einem When Step und ohne Given f√ºr den gleichen Request.

Szenario: Kurze Ermittlung von mehreren Katzen Fakten
  Wenn ich nach 2 Katzen-Fakten frage
  Dann erwarte ich 2 Fakten √ºber Katzen
Umsetzen des Tests
In dem neuen Schritt Wenn ich nach 2 Katzen-Fakten frage werden nun alle Bestandteile des Requests direkt in einem Schritt geb√ºndelt. Die Zwischenspeicherung in den Attributen der World Klasse ist nicht notwendig.

When('ich nach {int} Katzen-Fakten frage', async function (this: ICustomWorld, limit: number) {
  this.requestResponse = await this.requestContext?.get('/facts', {
    params: { limit: limit },
  });
});
Testen von korrekten Security Headern als nicht-funktionale Anforderung
Zus√§tzlich zu den funktionalen Aspekten lassen sich auch nicht funktionale Aspekte von APIs-Testen. Dies kann sehr unterschiedlich ausfallen, aber die nachfolgende Aufgabe soll darstellen, wie beispielsweise Header ausgewertet werden k√∂nnen. Im Fokus steht dabei der Aspect der IT-Sicherheit, indem kontrolliert wird, dass hierf√ºr relevante Header entsprechend gesetzt werden. Weiterf√ºhrende Informationen zu sicherheitrelevanten Header von OWASP: HTTP-Header-Cheatsheet

Schreiben des Testfalls
In der Antwort der API sollen die folgenden Aspekte getestet werden:

Die API-Response setzt den korrekten Content-Type, um eine missbr√§uchliche Verwendung zu unterbinden, n√§mlich application/json
Die API-Response setzt den X-Frame-Option Header auf deny oder sameorigin, sodass der Inhalt der Response nicht ungewollt weiterverwendet wird.
Die API-Response gibt keine Details zur verwendeten Servertechnologie bekannt, sodass hier√ºber nicht einfach Angriffsvektoren identifiziert werden k√∂nnen.
Zus√§tzlich setzen eines Labels @sec, um im Nachgang einen dedizierten Bericht f√ºr IT-Sicherheit zu erm√∂glichen.

Wichtig! Diese Tests sind mit Fokus auf das hier verwendete Beispiel angelegt. Bei Verwendung der Schritte f√ºr eine reale Applikation, m√ºssen die Header der Anwendung explizit untersucht werden und potenzielle Anpassungen getroffen werden.

  @sec
  Szenario: Setzen sicherheitsrelevanter Header
    Wenn ich nach 2 Katzen-Fakten frage
    Dann erwarte ich "application/json" als content-type in der API-Antwort
    Und erwarte ich einen sicheren x-frame-options Header in der API-Antwort
    Und erwarte ich keine Server-Details in der API-Antwort
Umsetzen des Tests
Die Steps sind hier erneut allgemeing√ºltig und werden daher in der src/steps/general-api.steps.ts angelegt.

Die Header einer Response k√∂nnen aus der requestResponse via header() Methode ermittelt werden.
Die drei Anforderungen werden jeweils leicht unterschiedlich umgesetzt:
Der Content-Type kann als Parameter √ºbernommen werden und es findet ein Ableich statt, ob der ermittelte Header √ºbereinstimmt
Der X-Frame-Options Header kann zwei g√ºltige Werte besitzen. Diese gelten immer und sind nicht besonders variabel, wesshalb das Detail innerhalb des Steps versteckt wird. Zus√§tzlich wird √ºberpr√ºft, ob der Header explizit vorhanden ist, um eine potenzielle Fehleranalyse zu erleichtern.
Der Server-Header ist entweder nicht vorhanden oder enth√§lt keine Serverinformationen. Die Pr√ºfung kann auch in dieser Reihenfolge implementiert werden.
Then(
  'erwarte ich "{}" als content-type in der API-Antwort',
  async function (this: ICustomWorld, expectedContentType: number) {
    const headers = this.requestResponse?.headers();
    expect(headers!['content-type']).toEqual(expectedContentType);
  },
);

Then(
  'erwarte ich einen sicheren x-frame-options Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const xFrameHeader = this.requestResponse?.headers()['x-frame-options'];
    expect(xFrameHeader).toBeTruthy();
    expect(xFrameHeader?.toLowerCase()).toMatch(/^deny$|^sameorigin$/);
  },
);

Then('erwarte ich keine Server-Details in der API-Antwort', async function (this: ICustomWorld) {
  const serverHeader = this.requestResponse?.headers()['server'];
  if (!serverHeader) {
    // Wenn der Header nicht gesetzt wird, werden keine Informationen preisgegeben, daher ist der Test erfolgreich
    expect(serverHeader).toBeUndefined();
    return;
  }
  expect(serverHeader.toLowerCase()).not.toMatch(/nginx|tomcat/);
});
Ausf√ºhren der Tests
Bei der Ausf√ºhrung der Tests wird eine Abweichung in den Server-Details festgestellt. Dieses Verhalten ist gew√ºnscht und deutet auf tats√§chliche Sicherheitsverst√∂√üe des Taschenrechners hin.

Erweiterung der API-Security Tests
Es sind noch einige Header zus√§tzlich zu kontrollieren, welche nach einem √§hnlichen Muster wie die aufgezeigten Beispile funktionieren. Diese sind im foglenden noch exemplarisch aufgelistet:

@sec
  Szenario: Setzen sicherheitsrelevanter Header
    Wenn ich nach 2 Katzen-Fakten frage
    Dann erwarte ich "application/json" als content-type in der API-Antwort
    Und erwarte ich einen sicheren x-frame-options Header in der API-Antwort
    Und erwarte ich keine Server-Details in der API-Antwort
    Und erwarte ich einen sicheren cache-control Header in der API-Antwort
    Und erwarte ich einen sicheren content-security-policy Header in der API-Antwort
    Und erwarte ich einen sicheren strict-transport-security Header in der API-Antwort
    Und erwarte ich einen sicheren feature-policy Header in der API-Antwort
    Und erwarte ich einen sicheren referrer-policy Header in der API-Antwort
    Und erwarte ich einen sicheren x-content-type-option Header in der API-Antwort
Then(
  'erwarte ich einen sicheren cache-control Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const cacheControlHeader = this.requestResponse?.headers()['cache-control'];
    expect(cacheControlHeader).toBeTruthy();
    expect(cacheControlHeader?.toLowerCase()).toEqual('no-store');
  },
);

Then(
  'erwarte ich einen sicheren content-security-policy Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const CSPHeader = this.requestResponse?.headers()['content-security-policy'];
    expect(CSPHeader).toBeTruthy();
    expect(CSPHeader?.toLowerCase()).toEqual('no-store');
  },
);

Then(
  'erwarte ich einen sicheren strict-transport-security Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const strictTransportSecurityHeader =
      this.requestResponse?.headers()['strict-transport-security'];
    expect(strictTransportSecurityHeader).toBeTruthy();
    expect(strictTransportSecurityHeader?.toLowerCase()).toEqual('max-age=51536000; subdomains');
  },
);

Then(
  'erwarte ich einen sicheren feature-policy Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const featurePolicyHeader = this.requestResponse?.headers()['feature-policy'];
    expect(featurePolicyHeader).toBeTruthy();
    expect(featurePolicyHeader?.toLowerCase()).toEqual('none');
  },
);

Then(
  'erwarte ich einen sicheren referrer-policy Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const referrerPolicyHeader = this.requestResponse?.headers()['referrer-policy'];
    expect(referrerPolicyHeader).toBeTruthy();
    expect(referrerPolicyHeader?.toLowerCase()).toEqual('no-referrer');
  },
);

Then(
  'erwarte ich einen sicheren x-content-type-option Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const referrerPolicyHeader = this.requestResponse?.headers()['x-content-type-option'];
    expect(referrerPolicyHeader).toBeTruthy();
    expect(referrerPolicyHeader?.toLowerCase()).toEqual('nosniff');
  },
);
Erweiterung der Security Tests auf das Frontend
Vergleichbar zu den Security Tests im Backend, welche die zur√ºckgemeldeten Header kontrolliert haben, lassen sich auch die Header bei der Auslieferung der Artefakte im Frontend verifizieren.

Schreiben des Testfalls
Aktivieren des mitschneidens von Netzerk-Responses noch vor √∂ffnen des Taschenrechners
√ñffnen des Taschenrechners als zu testende Aktion.
Validierung der folgenden Header:
Die Response setzt nur die eigene Adresse als Access-Control-Allow-Origin Header
Die Response setzt einen Content-Security-Policy (CSP) Header
Die Response setzt den X-Frame-Option Header auf deny oder sameorigin, sodass der Inhalt der Response nicht ungewollt weiterverwendet wird.
Zus√§tzlich auch hier das setzten des @sec Labels.
Wichtig! Auch hier sind die letztendlichen Tests noch zu erweitern/anzupassen. Gerade das Thema CSP kann eine erh√∂hte Komplexit√§t annehmen.

@sec
  Szenario: Kontrolle der korrekten Header des Taschenrechners
    Gegeben sei ein aktives Monitoring der HTTP-Requests des Browsers
    Wenn ich den Taschenrechner √∂ffne
    Dann erwarte ich einen sicheren access-control-allow-origin Header der Web-Page
    Und erwarte ich einen gesetzten content-security-policy Header der Web-Page
    Und erwarte ich einen sicheren x-frame-options Header der Web-Page
Umsetzen des Tests
Gegeben sei ein aktives Monitoring der HTTP-Requests des Browsers
Verortung in den src/steps/general.steps.ts
Hinterlegen von tracedResponses: Request[] in der Custom World
Explizites Importieren von import { Response } from '@playwright/test';
Im Step zuerst einen die potentiell bereits erfassten Requests zur√ºcksetzen
Dann einen Listener f√ºr eingehende Respones hinterlegen, via page.on()
Weitere Informationen unter Events
Wenn ich den Taschenrechner √∂ffne
Vergleichbar zu den bereits implementierten Given Steps
Erstellen eines neuen Schrittes
Auslagern der URL in eine Konstante, um leichter auf √Ñnderungen zu reagieren.
Dann erwarte ich einen sicheren access-control-allow-origin Header der Web-Page
Identifikation aller relevanten Responses basierend auf der initialen Request-URL und einem Filter auf HTML-Anfragen
Hierf√ºr nutzer der Methoden request(), und url()
Danach Ermittlung und Kontrolle der Header
Ermittlung via allHeaders() Methode
Vergleichbare √ºberpr√ºfung zu den API Tests
Kontrolle auf Vorhandensein und den Wert <https://testsheepnz.github.io/>
Und erwarte ich einen gesetzten content-security-policy Header der Web-Page
Vergleichbar zum vorherigen Schritt
Augrund der Komplexit√§t nur erst einmal setzten des Headers
Und erwarte ich einen sicheren x-frame-options Header der Web-Page
Vergleichbar zu vorherigen Schritten und X-Frame-Options der API-Tests
calculator.steps.ts

const CALCULATOR_URL = 'https://testsheepnz.github.io/BasicCalculator.html';

Given('ein Taschenrechner', async function (this: ICustomWorld) {
  const { page } = this;
  await page?.goto('https://testsheepnz.github.io/BasicCalculator.html');
  await page?.goto(CALCULATOR_URL);
});

When('ich den Taschenrechner √∂ffne', async function (this: ICustomWorld) {
  await this.page?.goto(CALCULATOR_URL);
});
general.steps.ts

Given('ein aktives Monitoring der HTTP-Requests des Browsers', async function (this: ICustomWorld) {
  this.tracedResponses = [];
  this.page?.on('response', (response) => this.tracedResponses?.push(response));
});

Then(
  'erwarte ich einen sicheren access-control-allow-origin Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = this.tracedResponses!.filter((res) =>
      res.request().url().includes('.html'),
    );
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      const CORSHeader = headers['access-control-allow-origin'];
      expect(CORSHeader).toBeTruthy();
      expect(CORSHeader.toLowerCase()).toBe('https://testsheepnz.github.io/');
    }
  },
);

Then(
  'erwarte ich einen gesetzten content-security-policy Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = this.tracedResponses!.filter((res) =>
      res.request().url().includes('.html'),
    );
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      console.log(headers);
      expect(headers['content-security-policy']).toBeTruthy();
    }
  },
);

Then(
  'erwarte ich einen sicheren x-frame-options Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = this.tracedResponses!.filter((res) =>
      res.request().url().includes('.html'),
    );
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      const xFrameHeader = headers['x-frame-options'];
      expect(xFrameHeader).toBeTruthy();
      expect(xFrameHeader.toLowerCase()).toMatch(/^deny$|^sameorigin$/);
    }
  },
);
Optimierung des Codes, indem die Ermittlung der relevanten Header in eine eigene Funktion namens getResponsesByHtmlRequest ausgelagert wird.

import { expect, Response } from '@playwright/test';

function getResponsesByHtmlRequest(responses: Response[]) {
  return responses.filter((res) => res.request().url().includes('.html'));
}

Then(
  'erwarte ich einen sicheren access-control-allow-origin Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = getResponsesByHtmlRequest(this.tracedResponses!);
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      const CORSHeader = headers['access-control-allow-origin'];
      expect(CORSHeader).toBeTruthy();
      expect(CORSHeader.toLowerCase()).toBe('https://testsheepnz.github.io/');
    }
  },
);

Then(
  'erwarte ich einen gesetzten content-security-policy Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = getResponsesByHtmlRequest(this.tracedResponses!);
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      console.log(headers);
      expect(headers['content-security-policy']).toBeTruthy();
    }
  },
);

Then(
  'erwarte ich einen sicheren x-frame-options Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = getResponsesByHtmlRequest(this.tracedResponses!);
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      const xFrameHeader = headers['x-frame-options'];
      expect(xFrameHeader).toBeTruthy();
      expect(xFrameHeader.toLowerCase()).toMatch(/^deny$|^sameorigin$/);
    }
  },
);
Ausf√ºhren der Tests
Bei der Ausf√ºhrung der Tests wird eine Abweichung in den Access-Control-Allow-Origin Headern.. Dieses Verhalten ist gew√ºnscht und deutet auf tats√§chliche Sicherheitsverst√∂√üe des Taschenrechners hin.

Letzte Optimierung zum Caching
Da in der Anwendung explizit ein Caching erlaubt wird, kann es zu ungew√ºnschten Nebeneffekten bei der wiederholten Ausf√ºhrung von Tests kommen. Hierzu setzen wir einen kleinen Workaround ein, um das Caching zu deaktivieren.

Siehe page.route

async function clearBrowserCache(page: Page) {
  await page.route('**', (route) => route.continue());
}

Given('ein aktives Monitoring der HTTP-Requests des Browsers', async function (this: ICustomWorld) {
  await clearBrowserCache(this.page!);
  this.tracedResponses = [];
  this.page?.on('response', (response) => this.tracedResponses?.push(response));
});
Zusammenfassung der relevanten Dateien
addition.feature

# language: de

@feature-1
Funktionalit√§t: Addition des Taschenrechners
  In meiner Rolle als Buchhalter*in m√∂chte ich zwei Zahlen miteinander addieren k√∂nnen,
  damit mir bei der Rechnungserstellung keine Fehler unterlaufen

  Grundlage:
    Gegeben sei ein Taschenrechner

  Szenariogrundriss: Addition von zwei Zahlen
    Wenn ich als erste Zahl <zahl1> eingebe
    Und ich als zweite Zahl <zahl2> eingebe
    Und ich Addition als Operation ausw√§hle
    Und ich das Ergebnis berechne
    Dann erwarte ich <ergebnis> als Ergebnis

    Beispiele: 
      | zahl1 | zahl2 | ergebnis |
      |     3 |     4 |        7 |
      |   3.3 |   4.4 |      7.7 |
      |     0 |     4 |        4 |
      |    -1 |     4 |        3 |

  Szenario: Addieren und Runden
    Gegeben seien die addierten Zahlen 3.3 und 4.4
    Wenn ich das Ergebnis runde
    Dann erwarte ich 7 als Ergebnis

  @a11y
  Szenario: Nach einer Berechnung erwarte ich keine Barrierefreiheitsfehler
    Gegeben seien die addierten Zahlen 5 und 5
    Wenn ich das Ergebnis runde
    Dann erwarte ich keine Barrierefreiheitsfehler auf dieser Seite

  @a11y
  Szenario: Nach einer Berechnung erwarte ich valides HTML
    Gegeben seien die addierten Zahlen 5 und 5
    Wenn ich das Ergebnis runde
    Dann erwarte ich valides HTML auf dieser Seite

  @sec
  Szenario: Kontrolle der korrekten Header des Taschenrechners
    Gegeben sei ein aktives Monitoring der HTTP-Requests des Browsers
    Wenn ich den Taschenrechner √∂ffne
    Dann erwarte ich einen sicheren access-control-allow-origin Header der Web-Page
    Und erwarte ich einen gesetzten content-security-policy Header der Web-Page
    Und erwarte ich einen sicheren x-frame-options Header der Web-Page
cats.feature

# language: de

@feature-3
Funktionalit√§t: Automatische Ermittlung n√ºtzlicher Fakten √ºber Katzen
  In meiner Rolle als Buchhalter*in m√∂chte interessante Fakten √ºber Katzen lernen,
  um mich von den schweren Kalkulationen zu erholen.

  Szenario: Ermittlung von mehreren Katzen-Fakten
    Gegeben sei ein Request an die Katzen-Fakten-API
    Wenn ich als limit Parameter 2 setze
    Und ich den Request absende
    Dann erwarte ich 2 Fakten √ºber Katzen

  Szenario: Kurze Ermittlung von mehreren Katzen Fakten
    Wenn ich nach 2 Katzen-Fakten frage
    Dann erwarte ich 2 Fakten √ºber Katzen

  @sec
  Szenario: Setzen sicherheitsrelevanter Header
    Wenn ich nach 2 Katzen-Fakten frage
    Dann erwarte ich "application/json" als content-type in der API-Antwort
    Und erwarte ich einen sicheren x-frame-options Header in der API-Antwort
    Und erwarte ich keine Server-Details in der API-Antwort
    Und erwarte ich einen sicheren cache-control Header in der API-Antwort
    Und erwarte ich einen sicheren content-security-policy Header in der API-Antwort
    Und erwarte ich einen sicheren strict-transport-security Header in der API-Antwort
    Und erwarte ich einen sicheren feature-policy Header in der API-Antwort
    Und erwarte ich einen sicheren referrer-policy Header in der API-Antwort
    Und erwarte ich einen sicheren x-content-type-option Header in der API-Antwort
general.steps.ts

import { ICustomWorld } from '../support/custom-world';
import { Given, Then } from '@cucumber/cucumber';
import { expect, Page, Response } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

// eslint-disable-next-line @typescript-eslint/no-var-requires
const htmlValidator = require('html-validator');

function getResponsesByHtmlRequest(responses: Response[]) {
  return responses.filter((res) => res.request().url().includes('.html'));
}

async function clearBrowserCache(page: Page) {
  await page.route('**', (route) => route.continue());
}

Given('ein aktives Monitoring der HTTP-Requests des Browsers', async function (this: ICustomWorld) {
  await clearBrowserCache(this.page!);
  this.tracedResponses = [];
  this.page?.on('response', (response) => this.tracedResponses?.push(response));
});

Then(
  'erwarte ich keine Barrierefreiheitsfehler auf dieser Seite',
  async function (this: ICustomWorld) {
    const page = this.page!;
    const a11yScans = await new AxeBuilder({ page }).analyze();
    const violations = a11yScans.violations;
    if (violations) {
      this.attach(JSON.stringify(violations), 'application/json');
    }
    expect(violations.length).toEqual(0);
  },
);

Then('erwarte ich valides HTML auf dieser Seite', async function (this: ICustomWorld) {
  const page = this.page!;
  const completePageHTML = await page.content();
  const options = {
    validator: 'WHATWG',
    data: completePageHTML,
  };
  const result = await htmlValidator(options);
  if (!result.isValid) {
    this.attach(JSON.stringify(result), 'application/json');
  }
  expect(result.isValid).toBeTruthy();
});

Then(
  'erwarte ich einen sicheren access-control-allow-origin Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = getResponsesByHtmlRequest(this.tracedResponses!);
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      console.log(headers);
      const CORSHeader = headers['access-control-allow-origin'];
      expect(CORSHeader).toBeTruthy();
      expect(CORSHeader.toLowerCase()).toBe('https://testsheepnz.github.io/');
    }
  },
);

Then(
  'erwarte ich einen gesetzten content-security-policy Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = getResponsesByHtmlRequest(this.tracedResponses!);
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      console.log(headers);
      expect(headers['content-security-policy']).toBeTruthy();
    }
  },
);

Then(
  'erwarte ich einen sicheren x-frame-options Header der Web-Page',
  async function (this: ICustomWorld) {
    const relevantRequests = getResponsesByHtmlRequest(this.tracedResponses!);
    for (const entry of relevantRequests) {
      const headers = await entry.allHeaders();
      const xFrameHeader = headers['x-frame-options'];
      expect(xFrameHeader).toBeTruthy();
      expect(xFrameHeader.toLowerCase()).toMatch(/^deny$|^sameorigin$/);
    }
  },
);
general-api.steps.ts

import { ICustomWorld } from '../support/custom-world';
import { Then, When } from '@cucumber/cucumber';
import { expect } from '@playwright/test';

When('ich den Request absende', async function (this: ICustomWorld) {
  this.requestResponse = await this.requestContext?.get(this.requestPath!, {
    params: this.requestParams,
  });
});

Then(
  'erwarte ich "{}" als content-type in der API-Antwort',
  async function (this: ICustomWorld, expectedContentType: number) {
    const headers = this.requestResponse?.headers();
    expect(headers!['content-type']).toEqual(expectedContentType);
  },
);

Then(
  'erwarte ich einen sicheren x-frame-options Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const xFrameHeader = this.requestResponse?.headers()['x-frame-options'];
    expect(xFrameHeader).toBeTruthy();
    expect(xFrameHeader?.toLowerCase()).toMatch(/^deny$|^sameorigin$/);
  },
);

Then('erwarte ich keine Server-Details in der API-Antwort', async function (this: ICustomWorld) {
  const serverHeader = this.requestResponse?.headers()['server'];
  if (!serverHeader) {
    // Wenn der Header nicht gesetzt wird, werden keine Informationen preisgegeben, daher ist der Test erfolgreich
    expect(serverHeader).toBeUndefined();
    return;
  }
  expect(serverHeader.toLowerCase()).not.toMatch(/nginx|tomcat/);
});

Then(
  'erwarte ich einen sicheren cache-control Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const cacheControlHeader = this.requestResponse?.headers()['cache-control'];
    expect(cacheControlHeader).toBeTruthy();
    expect(cacheControlHeader?.toLowerCase()).toEqual('no-store');
  },
);

Then(
  'erwarte ich einen sicheren content-security-policy Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const CSPHeader = this.requestResponse?.headers()['content-security-policy'];
    expect(CSPHeader).toBeTruthy();
    expect(CSPHeader?.toLowerCase()).toEqual('no-store');
  },
);

Then(
  'erwarte ich einen sicheren strict-transport-security Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const strictTransportSecurityHeader =
      this.requestResponse?.headers()['strict-transport-security'];
    expect(strictTransportSecurityHeader).toBeTruthy();
    expect(strictTransportSecurityHeader?.toLowerCase()).toEqual('max-age=51536000; subdomains');
  },
);

Then(
  'erwarte ich einen sicheren feature-policy Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const featurePolicyHeader = this.requestResponse?.headers()['feature-policy'];
    expect(featurePolicyHeader).toBeTruthy();
    expect(featurePolicyHeader?.toLowerCase()).toEqual('none');
  },
);

Then(
  'erwarte ich einen sicheren referrer-policy Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const referrerPolicyHeader = this.requestResponse?.headers()['referrer-policy'];
    expect(referrerPolicyHeader).toBeTruthy();
    expect(referrerPolicyHeader?.toLowerCase()).toEqual('no-referrer');
  },
);

Then(
  'erwarte ich einen sicheren x-content-type-option Header in der API-Antwort',
  async function (this: ICustomWorld) {
    const referrerPolicyHeader = this.requestResponse?.headers()['x-content-type-option'];
    expect(referrerPolicyHeader).toBeTruthy();
    expect(referrerPolicyHeader?.toLowerCase()).toEqual('nosniff');
  },
);
cat-api.steps.ts

import { ICustomWorld } from '../support/custom-world';
import { Given, Then, When } from '@cucumber/cucumber';
import { expect } from '@playwright/test';

Given('ein Request an die Katzen-Fakten-API', async function (this: ICustomWorld) {
  this.requestPath = '/facts';
});

When('ich als limit Parameter {int} setze', async function (this: ICustomWorld, value: number) {
  this.requestParams = { limit: value };
});

When('ich nach {int} Katzen-Fakten frage', async function (this: ICustomWorld, limit: number) {
  this.requestResponse = await this.requestContext?.get('/facts', {
    params: { limit: limit },
  });
});

Then(
  'erwarte ich {int} Fakten √ºber Katzen',
  async function (this: ICustomWorld, expectedResultCount: number) {
    const buffer = await this.requestResponse?.body();
    const result = JSON.parse(buffer!.toString());
    expect(result.data.length).toEqual(expectedResultCount);
    console.log(result.data.map((entry: { fact: string }) => entry.fact));
  },
);
calculator.steps.ts

import { ICustomWorld } from '../support/custom-world';
import { Given, Then, When } from '@cucumber/cucumber';
import { expect } from '@playwright/test';

const CALCULATOR_URL = 'https://testsheepnz.github.io/BasicCalculator.html';

Given('ein Taschenrechner', async function (this: ICustomWorld) {
  const { page } = this;
  await page?.goto(CALCULATOR_URL);
});

Given(
  'die addierten Zahlen {} und {}',
  async function (this: ICustomWorld, firstNumber: string, secondNumber: string) {
    const calculator = this.calculator!;
    await calculator.setFirstNumber(firstNumber);
    await calculator.setSecondNumber(secondNumber);
    await calculator.selectOperation('Addition');
    await calculator.calculateResult();
  },
);

When('ich den Taschenrechner √∂ffne', async function (this: ICustomWorld) {
  await this.page?.goto(CALCULATOR_URL);
});

When('ich als erste Zahl {} eingebe', async function (this: ICustomWorld, firstNumber: string) {
  await this.calculator?.setFirstNumber(firstNumber);
});

When('ich als zweite Zahl {} eingebe', async function (this: ICustomWorld, secondNumber: string) {
  await this.calculator?.setSecondNumber(secondNumber);
});

When('ich {} als Operation ausw√§hle', async function (this: ICustomWorld, operation: string) {
  await this.calculator?.selectOperation(operation);
});

When('ich das Ergebnis berechne', async function (this: ICustomWorld) {
  await this.calculator?.calculateResult();
});

When('ich das Ergebnis runde', async function (this: ICustomWorld) {
  await this.calculator?.RoundResult();
});

Then('erwarte ich {} als Ergebnis', async function (this: ICustomWorld, expectedResult: string) {
  const actualText = await this.calculator?.getResult();
  expect(actualText).toEqual(expectedResult);
});
common-hooks.ts (Auszug der relevanten Methode)

import { Calculator } from '../pages/Calculator';
//...
Before(async function (this: ICustomWorld, { pickle }: ITestCaseHookParameter) {
  this.startTime = new Date();
  this.testName = pickle.name.replace(/\W/g, '-');
  // customize the [browser context](https://playwright.dev/docs/next/api/class-browser#browsernewcontextoptions)
  this.context = await browser.newContext({
    acceptDownloads: true,
    recordVideo: process.env.PWVIDEO ? { dir: 'screenshots' } : undefined,
    viewport: { width: 1200, height: 800 },
  });
  this.requestContext = await request.newContext({
    // All requests we send go to this API endpoint.
    baseURL: config.BASE_API_URL,
  });

  await this.context.tracing.start({ screenshots: true, snapshots: true });
  this.page = await this.context.newPage();
  this.calculator = new Calculator(this.page);
  this.page.on('console', async (msg: ConsoleMessage) => {
    if (msg.type() === 'log') {
      await this.attach(msg.text());
    }
  });
  this.feature = pickle;
});
//...
config.ts

import { LaunchOptions } from '@playwright/test';
const browserOptions: LaunchOptions = {
  headless: false,
  slowMo: 0,
  args: ['--use-fake-ui-for-media-stream', '--use-fake-device-for-media-stream'],
  firefoxUserPrefs: {
    'media.navigator.streams.fake': true,
    'media.navigator.permission.disabled': true,
  },
};

export const config = {
  browser: process.env.BROWSER || 'chromium',
  browserOptions,
  BASE_URL: 'https://catfact.ninja',
  IMG_THRESHOLD: { threshold: 0.4 },
  BASE_API_URL: 'https://catfact.ninja/',
};
custom-world.ts

import { Calculator } from '../pages/Calculator';
import { setWorldConstructor, World, IWorldOptions } from '@cucumber/cucumber';
import * as messages from '@cucumber/messages';
import {
  BrowserContext,
  Page,
  PlaywrightTestOptions,
  APIRequestContext,
  APIResponse,
  Response,
} from '@playwright/test';

export interface CucumberWorldConstructorParams {
  parameters: { [key: string]: string };
}

export interface ICustomWorld extends World {
  debug: boolean;
  feature?: messages.Pickle;
  context?: BrowserContext;
  page?: Page;
  calculator?: Calculator;

  testName?: string;
  startTime?: Date;

  requestContext?: APIRequestContext;
  requestPath?: string;
  requestParams?: { [key: string]: string | number | boolean };
  requestResponse?: APIResponse;

  tracedResponses?: Response[];

  playwrightOptions?: PlaywrightTestOptions;
}

export class CustomWorld extends World implements ICustomWorld {
  constructor(options: IWorldOptions) {
    super(options);
  }
  debug = false;
}

setWorldConstructor(CustomWorld);
